# NumerusX - AI Agent API Integration (Google Gemini 2.5 Flash Preview) üß†‚ö°

**Objectif**: Int√©grer l'API Google Gemini 2.5 Flash Preview comme moteur de d√©cision principal pour l'`AIAgent` de NumerusX. Ce plan met l'accent sur une int√©gration efficace, une optimisation des co√ªts en minimisant les appels API par une pr√©paration minutieuse des donn√©es, et une interaction utilisateur claire concernant les d√©cisions de l'IA.

## Pr√©requis

* Un compte Google Cloud avec l'API Gemini activ√©e (via Vertex AI ou Google AI Studio) et une cl√© API.
* Compr√©hension de l'architecture de NumerusX, notamment le r√¥le de `AIAgent` et `DexBot` tels que d√©finis dans `0-architecte.md`.

## Mod√®le d'IA S√©lectionn√©

* **API**: Google AI (via Vertex AI ou Google AI Studio)
* **Mod√®le**: Gemini 2.5 Flash Preview (ou le nom exact du mod√®le au moment de l'impl√©mentation, ex: "gemini-2.5-flash-preview-XXXX")

## Phase 1: Configuration et Installation Initiale

### T√¢che 1.1: Mise √† Jour de la Configuration
-   **Objectif**: Ajouter les configurations n√©cessaires pour l'API Gemini.
-   **Fichier Concern√©**: `app/config.py`
-   **D√©tails**:
    -   [ ] Ajouter `GOOGLE_API_KEY` √† la classe `Config`. Charger depuis les variables d'environnement.
    -   [ ] Ajouter `GEMINI_MODEL_NAME` (ex: "gemini-2.5-flash-preview-XXXX") √† `Config`.
    -   [ ] Ajouter `GEMINI_API_TIMEOUT_SECONDS` (ex: 15-25 secondes, Gemini Flash est con√ßu pour √™tre rapide) √† `Config`.
    -   [ ] Ajouter `GEMINI_MAX_TOKENS_INPUT` (ex: 4096) √† `Config` et l'utiliser dans `GeminiClient` pour la configuration de g√©n√©ration.
    -   [ ] S'assurer que la cl√© API n'est pas commit√©e (utilisation de `.env` et `python-dotenv`).

### T√¢che 1.2: Ajout de la D√©pendance
-   **Objectif**: Inclure la biblioth√®que Python de Google pour Gemini.
-   **Fichier Concern√©**: `requirements.txt`
-   **D√©tails**:
    -   [ ] Ajouter `google-generativeai` (ou `google-cloud-aiplatform` si l'int√©gration se fait via Vertex AI) √† `requirements.txt`. V√©rifier la version recommand√©e pour Gemini 2.5 Flash.

## Phase 2: Client API Gemini

### T√¢che 2.1: Cr√©ation du Client API Gemini
-   **Objectif**: D√©velopper une classe cliente pour interagir avec l'API Gemini.
-   **Fichier Concern√©**: `app/ai_agent/gemini_client.py` (Nouveau fichier dans `app/ai_agent/`)
-   **D√©tails**:
    -   [ ] Cr√©er une classe `GeminiClient`.
    -   [ ] Initialiser le client avec la cl√© API et le nom du mod√®le depuis `Config`.
        ```python
        import google.generativeai as genai

        class GeminiClient:
            def __init__(self, api_key: str, model_name: str):
                genai.configure(api_key=api_key)
                self.model = genai.GenerativeModel(model_name)
                # Configurer des safety_settings appropri√©s pour √©viter des blocages trop stricts si le contenu financier est mal interpr√©t√©.
                self.safety_settings = [
                    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
                ]
                self.generation_config = genai.types.GenerationConfig(
                    # max_output_tokens=8192, # Flash a une grande fen√™tre, mais sp√©cifier pour la sortie
                    temperature=0.2, # Plus d√©terministe pour les d√©cisions financi√®res
                    # top_p=0.8, # Optionnel
                    # top_k=40   # Optionnel
                )
        ```
    -   [ ] Impl√©menter une m√©thode asynchrone `get_decision(self, structured_prompt: str, max_output_tokens: int = 1024) -> Dict[str, Any]`.
        -   Cette m√©thode enverra le `structured_prompt` (qui sera un JSON string ou un objet Python converti en string pour le prompt) √† l'API Gemini.
        -   Elle utilisera `model.generate_content_async()` pour les appels asynchrones.
        -   Elle devra g√©rer la r√©ponse et extraire le texte pertinent.
        -   Retourner une r√©ponse structur√©e (ex: `{'success': True, 'decision_text': '...', 'usage_metadata': ...}`).
    -   [ ] Inclure la gestion des timeouts configur√©e dans `Config`. (Note: la biblioth√®que `google-generativeai` g√®re les timeouts via les param√®tres de la requ√™te ou la configuration du client HTTP sous-jacent. √Ä v√©rifier lors de l'impl√©mentation).

### T√¢che 2.2: Gestion des Erreurs API dans le Client Gemini
-   **Objectif**: G√©rer les erreurs sp√©cifiques √† l'API Gemini.
-   **Fichier Concern√©**: `app/ai_agent/gemini_client.py`
-   **D√©tails**:
    -   [ ] Dans `get_decision`, intercepter les exceptions sp√©cifiques de la biblioth√®que Google (ex: `google.api_core.exceptions.GoogleAPIError`, `DeadlineExceeded`, `ResourceExhausted`, etc.).
    -   [ ] G√©rer les r√©ponses de l'API qui indiquent un blocage par les filtres de s√©curit√© (si `BLOCK_NONE` n'est pas suffisant ou si des probl√®mes persistent) et ajuster les `safety_settings` ou le prompt.
    -   [ ] Retourner une r√©ponse d'erreur structur√©e (ex: `{'success': False, 'error': 'Gemini API Error: ...', 'data': None}`).
    -   [ ] Journaliser les erreurs API avec des d√©tails pertinents (type d'erreur, message).

## Phase 3: Int√©gration avec `AIAgent` et Optimisation du Prompt

### T√¢che 3.1: Modification de `AIAgent` pour Utiliser `GeminiClient`
-   **Objectif**: Adapter `AIAgent` pour qu'il utilise `GeminiClient` pour prendre ses d√©cisions.
-   **Fichier Concern√©**: `app/ai_agent.py`
-   **D√©tails**:
    -   [ ] Importer et initialiser `GeminiClient` dans le constructeur de `AIAgent`.
    -   [ ] La m√©thode `decide_trade(self, aggregated_inputs: Dict)` de `AIAgent` doit:
        -   **Pr√©parer un prompt unique et complet** √† partir des `aggregated_inputs`. L'objectif est de faire un seul appel API par cycle de d√©cision.
        -   Appeler `self.gemini_client.get_decision(prompt_text)`.
        -   Parser la r√©ponse texte du LLM (qui devrait √™tre un JSON structur√© comme demand√© dans le prompt) pour extraire la d√©cision de trade et le raisonnement.

### T√¢che 3.2: Conception du Prompt Optimis√© pour Gemini 2.5 Flash (Co√ªt et Efficacit√©)
-   **Objectif**: Cr√©er un prompt tr√®s structur√© et concis pour Gemini 2.5 Flash, afin d'obtenir des r√©ponses pr√©cises tout en minimisant le nombre de tokens d'entr√©e et de sortie.
-   **Fichier Concern√©**: Logique de construction du prompt dans `app/ai_agent.py`.
-   **D√©tails**:
    -   [ ] **R√¥le et Contexte Principal**: D√©finir clairement que l'IA est un agent de trading pour NumerusX sur Solana, sp√©cialis√© dans l'analyse de multiples sources de donn√©es pour prendre des d√©cisions d'achat, de vente ou de conservation.
    -   [ ] **Formatage des Donn√©es d'Entr√©e**:
        -   Fournir les `aggregated_inputs` sous forme de JSON stringifi√© ou d'une structure textuelle tr√®s claire et compacte.
        -   Exemple de structure d'input (√† adapter et rendre concise) :
            ```text
            ROLE: NumerusX Solana Trading Agent. Analyze the following data for SOL/USDC and provide a trading decision.

            CURRENT MARKET DATA (SOL/USDC):
            - Price: $165.30
            - 24h Volume: $1.2B
            - Liquidity: $25M
            - Recent Trend (1h): Upward
            - Key Support: $160.00
            - Key Resistance: $170.00

            TECHNICAL INDICATORS (1h):
            - RSI: 68 (Approaching Overbought)
            - MACD: Bullish Crossover (Signal Strength: 0.7/1.0)
            - Bollinger Bands: Price near Upper Band (Width: 5%)

            AI PREDICTIONS (for SOL):
            - Price Prediction (next 4h): $168.00 - $172.00 (Confidence: 0.75)
            - Market Regime: Volatile-Trending
            - Sentiment Score (Social Media): 0.6 (Positive, Volume: High)

            RISK PARAMETERS:
            - Max Portfolio Exposure per Trade: 2%
            - Current Portfolio Value: $10,000 USD
            - Available Capital: $4,000 USDC
            - Current Open Positions (SOL/USDC): None (or details if any)

            TOKEN SECURITY (SOL):
            - Security Score: 0.9/1.0 (Low Risk)
            - Recent Alerts: None

            INSTRUCTIONS:
            Based ONLY on the provided data, decide to BUY, SELL, or HOLD SOL/USDC.
            If BUY or SELL:
              - Specify amount_usd to trade (consider risk parameters and available capital).
              - Suggest stop_loss_price and take_profit_price.
            Output your decision and reasoning STRICTLY in the following JSON format:
            {
              "decision": "BUY" | "SELL" | "HOLD",
              "token_pair": "SOL/USDC",
              "amount_usd": float | null, // Amount in USDC for the trade
              "confidence": float, // Your confidence in this decision (0.0 to 1.0)
              "stop_loss_price": float | null,
              "take_profit_price": float | null,
              "reasoning": " concise explanation based on synthesized data points."
            }
            Prioritize capital preservation. If data is conflicting or insufficient for a high-confidence trade, prefer HOLD.
            Be concise in your reasoning.
            ```
    -   [ ] **Instructions de Format de Sortie (Crucial pour le Co√ªt)**:
        -   Demander explicitement une sortie JSON structur√©e et concise. Pr√©ciser les champs attendus et leurs types. Cela r√©duit le nombre de tokens de sortie et facilite le parsing.
        -   Limiter la longueur du champ "reasoning" si n√©cessaire (ex: `max_output_tokens` dans `generation_config`).
    -   [ ] **Strat√©gie "Single Shot"**:
        -   Assurer que `DexBot` collecte et agr√®ge **toutes** les informations n√©cessaires **avant** de construire le prompt.
        -   L'objectif est d'obtenir une d√©cision et un raisonnement complets en un seul appel √† l'API Gemini pour chaque cycle de d√©cision du bot. Pas de conversation ou d'appels multiples pour une seule d√©cision.
    -   [ ] **Minimisation des Tokens d'Entr√©e**:
        -   Utiliser des abr√©viations standard si possible.
        -   Fournir des valeurs num√©riques directement, √©viter les phrases longues pour les donn√©es.
        -   √âliminer toute information redondante ou non essentielle √† la prise de d√©cision imm√©diate.

### T√¢che 3.3: Parsing Robuste et Validation de la R√©ponse JSON de Gemini
-   **Objectif**: Extraire de mani√®re fiable la d√©cision structur√©e de la r√©ponse texte de Gemini.
-   **Fichier Concern√©**: `app/ai_agent.py`
-   **D√©tails**:
    -   [ ] Dans `AIAgent.decide_trade`, apr√®s avoir re√ßu la r√©ponse de `GeminiClient`:
        -   [ ] V√©rifier le succ√®s de l'appel.
        -   [ ] Extraire le contenu textuel de la r√©ponse.
        -   [ ] Tenter de parser ce texte comme un JSON.
        -   [ ] Valider rigoureusement la structure du JSON par rapport au format attendu (champs, types).
            - [ ] Impl√©menter la validation de la structure JSON de sortie avec `pydantic` en utilisant un mod√®le comme suit (√† adapter si n√©cessaire) :
              ```python
              from pydantic import BaseModel, confloat, conlist, constr # Ajouter Optional, Literal
              from typing import Optional, Literal # Importer Optional et Literal

              class TradeDecision(BaseModel):
                  decision: Literal["BUY", "SELL", "HOLD"]
                  token_pair: str
                  amount_usd: Optional[confloat(gt=0)]
                  confidence: confloat(ge=0, le=1)
                  reasoning: constr(max_length=500)
              ```
        -   [ ] G√©rer les cas o√π le LLM retourne un JSON malform√© ou incomplet. Impl√©menter des reintentions avec un prompt l√©g√®rement modifi√© (ex: "Please ensure output is valid JSON.") si cela arrive occasionnellement, ou un fallback s√ªr (HOLD).
        -   [ ] Convertir la d√©cision pars√©e en l'objet `Ordre de Trade Final` utilis√© par `DexBot`.

## Phase 4: Journalisation, M√©canismes de Fallback et Tests

### T√¢che 4.1: Journalisation D√©taill√©e des Interactions avec Gemini
-   **Objectif**: Assurer une tra√ßabilit√© compl√®te pour le d√©bogage, l'audit et l'am√©lioration des prompts.
-   **Fichiers Concern√©s**: `app/ai_agent/gemini_client.py`, `app/ai_agent.py`, `app/logger.py`
-   **D√©tails**:
    -   [ ] Journaliser le prompt complet envoy√© √† l'API Gemini.
    -   [ ] Journaliser la r√©ponse brute (texte) re√ßue de l'API.
    -   [ ] Journaliser la d√©cision structur√©e pars√©e et le raisonnement.
    -   [ ] Journaliser les m√©tadonn√©es d'utilisation (nombre de tokens d'entr√©e/sortie si l'API les fournit) pour chaque appel.
    -   [ ] Mesurer et journaliser le temps de r√©ponse de l'API.

### T√¢che 4.2: M√©canismes de Reintentions et Fallback pour l'API Gemini
-   **Objectif**: Augmenter la r√©silience du syst√®me face aux √©checs ou latences de l'API Gemini.
-   **Fichier Concern√©**: `app/ai_agent/gemini_client.py`, `app/ai_agent.py`
-   **D√©tails**:
    -   [ ] Utiliser `tenacity` pour impl√©menter des reintentions avec backoff exponentiel pour les appels √† `gemini_client.get_decision` en cas d'erreurs r√©seau, de `DeadlineExceeded`, ou `ResourceExhausted`.
    -   [ ] Si l'API Gemini retourne une erreur indiquant un probl√®me avec le prompt (ex: contenu bloqu√© malgr√© les `safety_settings`), `AIAgent` pourrait tenter de reformuler l√©g√®rement le prompt ou de r√©duire la quantit√© de donn√©es textuelles sensibles.
    -   [ ] En cas d'√©checs r√©p√©t√©s ou si la r√©ponse n'est pas parsable apr√®s reintentions, `AIAgent` doit d√©clencher une strat√©gie de fallback :
        -   Option 1: Utiliser une logique de d√©cision simplifi√©e interne (ex: bas√©e sur `AdvancedTradingStrategy` uniquement).
        -   Option 2: √âmettre un signal HOLD avec un niveau de confiance faible et journaliser l'incident de mani√®re critique.
        -   Option 3 (Plus avanc√©e): Utiliser un mod√®le LLM local plus petit comme fallback (si disponible et pertinent).

### T√¢che 4.3: Tests d'Int√©gration et de Robustesse
-   **Objectif**: Valider l'int√©gration de l'API Gemini et la fiabilit√© des d√©cisions.
-   **D√©tails**:
    -   [ ] Tests unitaires pour `GeminiClient` en simulant (mocking) les r√©ponses de l'API Gemini (succ√®s, erreurs, contenu bloqu√©).
    -   [ ] Tests d'int√©gration pour `AIAgent` v√©rifiant la construction du prompt, l'appel au `GeminiClient`, le parsing de la r√©ponse JSON, et la gestion des erreurs/fallback.
    -   [ ] Cr√©er des sc√©narios de test avec divers `aggregated_inputs` (y compris des donn√©es manquantes ou contradictoires) pour observer le comportement de l'IA et la robustesse du parsing.
    -   [ ] √âvaluer la latence de bout en bout du cycle de d√©cision incluant l'appel √† l'API Gemini.
    -   [ ] Inclure un cas de test comme `async def test_decision_parsing(mocker)` pour valider le parsing des d√©cisions simul√©es du `GeminiClient` par `AIAgent` (ex: v√©rifier que `decision.action == "BUY"` pour une r√©ponse mock√©e appropri√©e).

## Phase 5: Int√©gration UI et Monitoring des Co√ªts

### T√¢che 5.1: Affichage des D√©cisions et Raisonnements IA dans le Dashboard
-   **Objectif**: Fournir √† l'utilisateur une transparence sur les d√©cisions prises par l'agent IA.
-   **Fichier Concern√©**: `app/dashboard.py`
-   **D√©tails**:
    -   [ ] Modifier `EnhancedDatabase` pour stocker le raisonnement de l'IA et les principaux inputs qui ont men√© √† la d√©cision.
    -   [ ] Dans la section "Trading Activity" ou une nouvelle section "AI Agent Log" du `NumerusXDashboard`, afficher :
        -   La d√©cision prise (BUY/SELL/HOLD).
        -   Le token concern√©.
        -   La confiance de l'IA.
        -   Le raisonnement textuel fourni par Gemini.
        -   Un r√©sum√© des indicateurs cl√©s que l'IA a mentionn√©s ou qui √©taient pr√©dominants dans le prompt.
    -   [ ] Permettre de visualiser le prompt envoy√© √† l'IA (peut-√™tre dans une vue "d√©tails avanc√©s" pour le d√©bogage).

### T√¢che 5.2: Suivi Actif des Co√ªts de l'API Gemini
-   **Objectif**: Surveiller et g√©rer les co√ªts associ√©s √† l'utilisation de l'API Gemini.
-   **Fichiers Concern√©s**: `app/ai_agent/gemini_client.py`, `app/logger.py`, potentiellement un nouveau module de monitoring.
-   **D√©tails**:
    -   [ ] Si l'API Gemini fournit des informations sur l'utilisation des tokens dans sa r√©ponse (`usage_metadata`), les extraire et les journaliser.
    -   [ ] Calculer une estimation du co√ªt par appel bas√© sur la tarification de Gemini 2.5 Flash (tokens d'entr√©e + tokens de sortie).
        - [ ] Impl√©menter une fonction `_calculate_cost(self, usage_metadata)` dans `GeminiClient` bas√©e sur les tarifs : entr√©e $0.50/million de tokens, sortie $1.50/million de tokens. Exemple :
          ```python
          # Dans GeminiClient
          # def _calculate_cost(self, usage_metadata): # Ou usage_dict si c'est ce que l'API retourne
          #     input_tokens = usage_metadata.get('prompt_token_count', 0) # ou usage_metadata.get('input_tokens', 0)
          #     output_tokens = usage_metadata.get('candidates_token_count', 0) # ou usage_metadata.get('output_tokens', 0)
          #     input_cost = (input_tokens / 1_000_000) * 0.50
          #     output_cost = (output_tokens / 1_000_000) * 1.50
          #     return input_cost + output_cost
          ```
    -   [ ] Journaliser le co√ªt estim√© par d√©cision.
    -   [ ] Mettre en place des seuils d'alerte dans le syst√®me de monitoring (ou via logs) si le co√ªt journalier/hebdomadaire d√©passe un budget pr√©d√©fini dans `Config`.

En suivant ces √©tapes, NumerusX pourra exploiter la vitesse et l'intelligence de Gemini 2.5 Flash pour prendre des d√©cisions de trading √©clair√©es, tout en gardant un contr√¥le sur les co√ªts et la robustesse du syst√®me.